import {
  useFieldContext
} from "./chunk-KPL4DKKN.js";
import {
  useEvent,
  useLocaleContext
} from "./chunk-24DFF2RX.js";
import {
  ark,
  compact,
  createAnatomy,
  createMachine,
  createProps,
  createSplitProps,
  createSplitProps2,
  guards,
  isEqual,
  mergeProps,
  normalizeProps,
  useMachine
} from "./chunk-GIOYOM5U.js";
import {
  useEnvironmentContext
} from "./chunk-VB3QDQ4Q.js";
import {
  createContext,
  createScope,
  dataAttr,
  dispatchInputCheckedEvent,
  getDocument,
  getEventTarget,
  getWindow,
  isMac,
  trackFormControl,
  trackPress,
  visuallyHiddenStyle
} from "./chunk-CVE3B77K.js";
import "./chunk-6B7WPHYS.js";
import {
  require_jsx_runtime
} from "./chunk-HAJ5MWBM.js";
import {
  require_react
} from "./chunk-IUESXVSS.js";
import {
  __export,
  __toESM
} from "./chunk-XPZLJQLW.js";

// node_modules/.pnpm/@ark-ui+react@4.9.2_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@ark-ui/react/dist/components/switch/use-switch-context.js
var [SwitchProvider, useSwitchContext] = createContext({
  name: "SwitchContext",
  hookName: "useSwitchContext",
  providerName: "<SwitchProvider />"
});

// node_modules/.pnpm/@ark-ui+react@4.9.2_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@ark-ui/react/dist/components/switch/switch-context.js
var SwitchContext = (props2) => props2.children(useSwitchContext());

// node_modules/.pnpm/@ark-ui+react@4.9.2_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@ark-ui/react/dist/components/switch/switch-control.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);
var SwitchControl = (0, import_react2.forwardRef)((props2, ref) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getControlProps(), props2);
  return (0, import_jsx_runtime.jsx)(ark.span, { ...mergedProps, ref });
});
SwitchControl.displayName = "SwitchControl";

// node_modules/.pnpm/@ark-ui+react@4.9.2_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@ark-ui/react/dist/components/switch/switch-hidden-input.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
var SwitchHiddenInput = (0, import_react4.forwardRef)(
  (props2, ref) => {
    const switchContext = useSwitchContext();
    const mergedProps = mergeProps(switchContext.getHiddenInputProps(), props2);
    const field = useFieldContext();
    return (0, import_jsx_runtime2.jsx)(ark.input, { "aria-describedby": field == null ? void 0 : field.ariaDescribedby, ...mergedProps, ref });
  }
);
SwitchHiddenInput.displayName = "SwitchHiddenInput";

// node_modules/.pnpm/@ark-ui+react@4.9.2_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@ark-ui/react/dist/components/switch/switch-label.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var SwitchLabel = (0, import_react6.forwardRef)((props2, ref) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getLabelProps(), props2);
  return (0, import_jsx_runtime3.jsx)(ark.span, { ...mergedProps, ref });
});
SwitchLabel.displayName = "SwitchLabel";

// node_modules/.pnpm/@ark-ui+react@4.9.2_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@ark-ui/react/dist/components/switch/switch-root.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);

// node_modules/.pnpm/@zag-js+focus-visible@0.82.2/node_modules/@zag-js/focus-visible/dist/index.mjs
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) return true;
  return event.detail === 0 && !event.pointerType;
}
function isValidKey(e) {
  return !(e.metaKey || !isMac() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
var nonTextInputTypes = /* @__PURE__ */ new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function isKeyboardFocusEvent(isTextInput, modality, e) {
  const target = e ? getEventTarget(e) : null;
  const win = getWindow(target);
  isTextInput = isTextInput || target instanceof win.HTMLInputElement && !nonTextInputTypes.has(target == null ? void 0 : target.type) || target instanceof win.HTMLTextAreaElement || target instanceof win.HTMLElement && target.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e instanceof win.KeyboardEvent && !Reflect.has(FOCUS_VISIBLE_INPUT_KEYS, e.key));
}
var currentModality = null;
var changeHandlers = /* @__PURE__ */ new Set();
var listenerMap = /* @__PURE__ */ new Map();
var hasEventBeforeFocus = false;
var hasBlurredWindowRecently = false;
var FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function triggerChangeHandlers(modality, e) {
  for (let handler of changeHandlers) {
    handler(modality, e);
  }
}
function handleKeyboardEvent(e) {
  hasEventBeforeFocus = true;
  if (isValidKey(e)) {
    currentModality = "keyboard";
    triggerChangeHandlers("keyboard", e);
  }
}
function handlePointerEvent(e) {
  currentModality = "pointer";
  if (e.type === "mousedown" || e.type === "pointerdown") {
    hasEventBeforeFocus = true;
    triggerChangeHandlers("pointer", e);
  }
}
function handleClickEvent(e) {
  if (isVirtualClick(e)) {
    hasEventBeforeFocus = true;
    currentModality = "virtual";
  }
}
function handleFocusEvent(e) {
  const target = getEventTarget(e);
  if (target === getWindow(target) || target === getDocument(target)) {
    return;
  }
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", e);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
}
function handleWindowBlur() {
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
}
function setupGlobalFocusEvents(root) {
  if (typeof window === "undefined" || listenerMap.get(getWindow(root))) {
    return;
  }
  const win = getWindow(root);
  const doc = getDocument(root);
  let focus = win.HTMLElement.prototype.focus;
  win.HTMLElement.prototype.focus = function() {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", null);
    hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  doc.addEventListener("keydown", handleKeyboardEvent, true);
  doc.addEventListener("keyup", handleKeyboardEvent, true);
  doc.addEventListener("click", handleClickEvent, true);
  win.addEventListener("focus", handleFocusEvent, true);
  win.addEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.addEventListener("pointerdown", handlePointerEvent, true);
    doc.addEventListener("pointermove", handlePointerEvent, true);
    doc.addEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.addEventListener("mousedown", handlePointerEvent, true);
    doc.addEventListener("mousemove", handlePointerEvent, true);
    doc.addEventListener("mouseup", handlePointerEvent, true);
  }
  win.addEventListener(
    "beforeunload",
    () => {
      tearDownWindowFocusTracking(root);
    },
    { once: true }
  );
  listenerMap.set(win, { focus });
}
var tearDownWindowFocusTracking = (root, loadListener) => {
  const win = getWindow(root);
  const doc = getDocument(root);
  if (!listenerMap.has(win)) {
    return;
  }
  win.HTMLElement.prototype.focus = listenerMap.get(win).focus;
  doc.removeEventListener("keydown", handleKeyboardEvent, true);
  doc.removeEventListener("keyup", handleKeyboardEvent, true);
  doc.removeEventListener("click", handleClickEvent, true);
  win.removeEventListener("focus", handleFocusEvent, true);
  win.removeEventListener("blur", handleWindowBlur, false);
  if (typeof win.PointerEvent !== "undefined") {
    doc.removeEventListener("pointerdown", handlePointerEvent, true);
    doc.removeEventListener("pointermove", handlePointerEvent, true);
    doc.removeEventListener("pointerup", handlePointerEvent, true);
  } else {
    doc.removeEventListener("mousedown", handlePointerEvent, true);
    doc.removeEventListener("mousemove", handlePointerEvent, true);
    doc.removeEventListener("mouseup", handlePointerEvent, true);
  }
  listenerMap.delete(win);
};
function isFocusVisible() {
  return currentModality === "keyboard";
}
function trackFocusVisible(props2 = {}) {
  const { isTextInput, autoFocus, onChange, root } = props2;
  setupGlobalFocusEvents(root);
  onChange == null ? void 0 : onChange({ isFocusVisible: autoFocus || isFocusVisible(), modality: currentModality });
  const handler = (modality, e) => {
    if (!isKeyboardFocusEvent(!!isTextInput, modality, e)) return;
    onChange == null ? void 0 : onChange({ isFocusVisible: isFocusVisible(), modality });
  };
  changeHandlers.add(handler);
  return () => {
    changeHandlers.delete(handler);
  };
}

// node_modules/.pnpm/@zag-js+switch@0.82.2/node_modules/@zag-js/switch/dist/index.mjs
var anatomy = createAnatomy("switch").parts("root", "label", "control", "thumb");
var parts = anatomy.build();
var dom = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `switch:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `switch:${ctx.id}:label`;
  },
  getThumbId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.thumb) ?? `switch:${ctx.id}:thumb`;
  },
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `switch:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.hiddenInput) ?? `switch:${ctx.id}:input`;
  },
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom.getById(ctx, dom.getHiddenInputId(ctx))
});
function connect(state, send, normalize) {
  const disabled = state.context.isDisabled;
  const readOnly = state.context.readOnly;
  const checked = state.context.checked;
  const focused = !disabled && state.context.focused;
  const focusVisible = !disabled && state.context.focusVisible;
  const dataAttrs = {
    "data-active": dataAttr(state.context.active),
    "data-focus": dataAttr(focused),
    "data-focus-visible": dataAttr(focusVisible),
    "data-readonly": dataAttr(readOnly),
    "data-hover": dataAttr(state.context.hovered),
    "data-disabled": dataAttr(disabled),
    "data-state": state.context.checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(state.context.invalid)
  };
  return {
    checked,
    disabled,
    focused,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize.label({
        ...parts.root.attrs,
        ...dataAttrs,
        dir: state.context.dir,
        id: dom.getRootId(state.context),
        htmlFor: dom.getHiddenInputId(state.context),
        onPointerMove() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled) return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          if (disabled) return;
          const target = getEventTarget(event);
          if (target === dom.getHiddenInputEl(state.context)) {
            event.stopPropagation();
          }
        }
      });
    },
    getLabelProps() {
      return normalize.element({
        ...parts.label.attrs,
        ...dataAttrs,
        dir: state.context.dir,
        id: dom.getLabelId(state.context)
      });
    },
    getThumbProps() {
      return normalize.element({
        ...parts.thumb.attrs,
        ...dataAttrs,
        dir: state.context.dir,
        id: dom.getThumbId(state.context),
        "aria-hidden": true
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts.control.attrs,
        ...dataAttrs,
        dir: state.context.dir,
        id: dom.getControlId(state.context),
        "aria-hidden": true
      });
    },
    getHiddenInputProps() {
      return normalize.input({
        id: dom.getHiddenInputId(state.context),
        type: "checkbox",
        required: state.context.required,
        defaultChecked: checked,
        disabled,
        "aria-labelledby": dom.getLabelId(state.context),
        "aria-invalid": state.context.invalid,
        name: state.context.name,
        form: state.context.form,
        value: state.context.value,
        style: visuallyHiddenStyle,
        onFocus() {
          const focusVisible2 = isFocusVisible();
          send({ type: "CONTEXT.SET", context: { focused: true, focusVisible: focusVisible2 } });
        },
        onBlur() {
          send({ type: "CONTEXT.SET", context: { focused: false, focusVisible: false } });
        },
        onClick(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "switch",
      initial: "ready",
      context: {
        checked: false,
        label: "switch",
        value: "on",
        disabled: false,
        ...ctx,
        fieldsetDisabled: false,
        focusVisible: false
      },
      computed: {
        isDisabled: (ctx2) => ctx2.disabled || ctx2.fieldsetDisabled
      },
      watch: {
        disabled: "removeFocusIfNeeded",
        checked: "syncInputElement"
      },
      activities: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
      on: {
        "CHECKED.TOGGLE": [
          {
            guard: not("isTrusted"),
            actions: ["toggleChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["toggleChecked"]
          }
        ],
        "CHECKED.SET": [
          {
            guard: not("isTrusted"),
            actions: ["setChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["setChecked"]
          }
        ],
        "CONTEXT.SET": {
          actions: ["setContext"]
        }
      },
      states: {
        ready: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackPressEvent(ctx2) {
          if (ctx2.isDisabled) return;
          return trackPress({
            pointerNode: dom.getRootEl(ctx2),
            keyboardNode: dom.getHiddenInputEl(ctx2),
            isValidKey: (event) => event.key === " ",
            onPress: () => ctx2.active = false,
            onPressStart: () => ctx2.active = true,
            onPressEnd: () => ctx2.active = false
          });
        },
        trackFocusVisible(ctx2) {
          if (ctx2.isDisabled) return;
          return trackFocusVisible({ root: dom.getRootNode(ctx2) });
        },
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "CHECKED.SET", checked: !!initialContext.checked, src: "form-reset" });
            }
          });
        }
      },
      actions: {
        setContext(ctx2, evt) {
          Object.assign(ctx2, evt.context);
        },
        syncInputElement(ctx2) {
          const inputEl = dom.getHiddenInputEl(ctx2);
          if (!inputEl) return;
          inputEl.checked = !!ctx2.checked;
        },
        removeFocusIfNeeded(ctx2) {
          if (ctx2.disabled && ctx2.focused) {
            ctx2.focused = false;
          }
        },
        setChecked(ctx2, evt) {
          set.checked(ctx2, evt.checked);
        },
        toggleChecked(ctx2, _evt) {
          set.checked(ctx2, !ctx2.checked);
        },
        dispatchChangeEvent(ctx2) {
          const inputEl = dom.getHiddenInputEl(ctx2);
          dispatchInputCheckedEvent(inputEl, { checked: ctx2.checked });
        }
      }
    }
  );
}
var invoke = {
  change: (ctx) => {
    var _a;
    (_a = ctx.onCheckedChange) == null ? void 0 : _a.call(ctx, { checked: ctx.checked });
  }
};
var set = {
  checked: (ctx, checked) => {
    if (isEqual(ctx.checked, checked)) return;
    ctx.checked = checked;
    invoke.change(ctx);
  }
};
var props = createProps()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "label",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps = createSplitProps(props);

// node_modules/.pnpm/@ark-ui+react@4.9.2_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@ark-ui/react/dist/components/switch/use-switch.js
var import_react8 = __toESM(require_react(), 1);
var useSwitch = (props2 = {}) => {
  const { getRootNode } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const field = useFieldContext();
  const initialContext = {
    id: (0, import_react8.useId)(),
    ids: {
      label: field == null ? void 0 : field.ids.label,
      hiddenInput: field == null ? void 0 : field.ids.control
    },
    dir,
    disabled: field == null ? void 0 : field.disabled,
    readOnly: field == null ? void 0 : field.readOnly,
    invalid: field == null ? void 0 : field.invalid,
    required: field == null ? void 0 : field.required,
    getRootNode,
    checked: props2.defaultChecked,
    ...props2
  };
  const context = {
    ...initialContext,
    checked: props2.checked,
    onCheckedChange: useEvent(props2.onCheckedChange, { sync: true })
  };
  const [state, send] = useMachine(machine(initialContext), { context });
  return connect(state, send, normalizeProps);
};

// node_modules/.pnpm/@ark-ui+react@4.9.2_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@ark-ui/react/dist/components/switch/switch-root.js
var SwitchRoot = (0, import_react10.forwardRef)((props2, ref) => {
  const [switchProps, localProps] = createSplitProps2()(props2, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "label",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const switchContext = useSwitch(switchProps);
  const mergedProps = mergeProps(switchContext.getRootProps(), localProps);
  return (0, import_jsx_runtime4.jsx)(SwitchProvider, { value: switchContext, children: (0, import_jsx_runtime4.jsx)(ark.label, { ...mergedProps, ref }) });
});
SwitchRoot.displayName = "SwitchRoot";

// node_modules/.pnpm/@ark-ui+react@4.9.2_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@ark-ui/react/dist/components/switch/switch-root-provider.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var SwitchRootProvider = (0, import_react12.forwardRef)(
  (props2, ref) => {
    const [{ value: api }, localProps] = createSplitProps2()(props2, ["value"]);
    const mergedProps = mergeProps(api.getRootProps(), localProps);
    return (0, import_jsx_runtime5.jsx)(SwitchProvider, { value: api, children: (0, import_jsx_runtime5.jsx)(ark.label, { ...mergedProps, ref }) });
  }
);
SwitchRootProvider.displayName = "SwitchRootProvider";

// node_modules/.pnpm/@ark-ui+react@4.9.2_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@ark-ui/react/dist/components/switch/switch-thumb.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);
var SwitchThumb = (0, import_react14.forwardRef)((props2, ref) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getThumbProps(), props2);
  return (0, import_jsx_runtime6.jsx)(ark.span, { ...mergedProps, ref });
});
SwitchThumb.displayName = "SwitchThumb";

// node_modules/.pnpm/@ark-ui+react@4.9.2_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/@ark-ui/react/dist/components/switch/switch.js
var switch_exports = {};
__export(switch_exports, {
  Context: () => SwitchContext,
  Control: () => SwitchControl,
  HiddenInput: () => SwitchHiddenInput,
  Label: () => SwitchLabel,
  Root: () => SwitchRoot,
  RootProvider: () => SwitchRootProvider,
  Thumb: () => SwitchThumb
});
export {
  switch_exports as Switch,
  SwitchContext,
  SwitchControl,
  SwitchHiddenInput,
  SwitchLabel,
  SwitchRoot,
  SwitchRootProvider,
  SwitchThumb,
  anatomy as switchAnatomy,
  useSwitch,
  useSwitchContext
};
//# sourceMappingURL=@ark-ui_react_switch.js.map
